# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

"""Merge meta data files generated by distributed converters."""
import os
from typing import List

import fsspec

from deepgnn.graph_engine._base import get_fs

# Content of sample meta.txt

# Fields            Description             Action
# ====================================================
# v1                binary version          equal
# 2708              node_count              additive
# 10556             edge_count              additive
# 4                 node_type_num           equal
# 1                 edge_type_num           equal
# 2                 node_xxx_feature_num    equal
# 0                 edge_xxx_feature_num    equal
# 1                 partitions count        equal
# 0                 Partition id            equal
# 140.0             node weight 1           additive
# 500.0             node weight 2           additive
# 1000.0            node weight 3           additive
# 1068.0            node weight 4           additive
# 10556.0           edge weight 1           additive
# 140               node count type 1       additive
# 500               node count type 2       additive
# 1000              node count type 3       additive
# 1068              node count type 4       additive
# 10556             edge count type 1       additive


class Meta:
    """Merge meta data files generated by distributed converters."""

    def __init__(self, fs: fsspec.AbstractFileSystem, path: str) -> None:
        """Initialize Meta merger.

        fs: abstract fsspec file system.
        path: path of the meta file.
        """
        self.fs = fs
        self.path = path
        self._from_file()

    def _from_file(self):
        with self.fs.open(self.path, "r") as meta:
            self.version = meta.readline().strip()
            if self.version[0] != "v":
                raise RuntimeError(
                    "First line in meta file should be version, please regenerate binary data"
                )

            self.node_count = int(meta.readline())
            self.edge_count = int(meta.readline())
            self.node_type_num = int(meta.readline())
            self.edge_type_num = int(meta.readline())
            self.node_feature_count = int(meta.readline())
            self.edge_feature_count = int(meta.readline())
            self.partition_count = int(meta.readline())
            self.partition_ids = []
            self.node_weights = [
                [float(0)] * self.node_type_num for _ in range(self.partition_count)
            ]
            self.edge_weights = [
                [float(0)] * self.edge_type_num for _ in range(self.partition_count)
            ]
            for p in range(self.partition_count):
                self.partition_ids.append(int(meta.readline()))  # Partition id
                for i in range(self.node_type_num):
                    self.node_weights[p][i] = float(meta.readline())
                for i in range(self.edge_type_num):
                    self.edge_weights[p][i] = float(meta.readline())

            self.node_count_per_type = []
            self.edge_count_per_type = []

            for _ in range(self.node_type_num):
                self.node_count_per_type.append(int(meta.readline()))
            for _ in range(self.edge_type_num):
                self.edge_count_per_type.append(int(meta.readline()))

    def get_partition(self):
        """Return the sub content of meta info."""
        return "\n".join(
            [
                str(p)
                + "\n"
                + "\n".join(
                    [str(self.node_weights[i][n]) for n in range(self.node_type_num)]
                )
                + "\n"
                + "\n".join(
                    [str(self.edge_weights[i][n]) for n in range(self.edge_type_num)]
                )
                for i, p in enumerate(self.partition_ids)
            ]
        )


def merge(fs, output_dir: str, meta_list: List[Meta]):
    """Merge meta files."""
    with fs.open("{}/meta.txt".format(output_dir), "w") as mtxt:
        assert all(
            map(lambda x: x.version == meta_list[0].version, meta_list)
        ), "All partitions must have the same binary version"
        mtxt.writelines(
            [
                str(meta_list[0].version),
                "\n",
                str(sum([i.node_count for i in meta_list])),
                "\n",
                str(sum([i.edge_count for i in meta_list])),
                "\n",
                str(meta_list[0].node_type_num),
                "\n",
                str(meta_list[0].edge_type_num),
                "\n",
                str(int(meta_list[0].node_feature_count)),
                "\n",
                str(int(meta_list[0].edge_feature_count)),
                "\n",
                str(sum([i.partition_count for i in meta_list])),
                "\n",
            ]
        )

        mtxt.writelines(["\n".join([i.get_partition() for i in meta_list]), "\n"])

        for count in range(int(meta_list[0].node_type_num)):
            mtxt.writelines(
                [str(sum([i.node_count_per_type[count] for i in meta_list])), "\n"]
            )
        for count in range(int(meta_list[0].edge_type_num)):
            mtxt.writelines(
                [str(sum([i.edge_count_per_type[count] for i in meta_list])), "\n"]
            )


def merge_metadata_files(meta_path: str):
    """Entrance of the merger."""
    fs, _ = get_fs(meta_path)

    total_files = [
        f if isinstance(f, str) else f["name"]
        for f in fs.glob(os.path.join(meta_path, "meta_*"))
    ]

    if len(total_files) == 0:
        return

    meta_list = [Meta(fs, f) for f in total_files]
    merge(fs, meta_path, meta_list)


if __name__ == "__main__":
    # import here for special usage of the module.
    import argparse

    parser = argparse.ArgumentParser(description="Merge all meta.txt.")
    parser.add_argument("-d", "--data_dir", help="meta.txt folder path")
    args = parser.parse_args()
    merge_metadata_files(args.data_dir)
